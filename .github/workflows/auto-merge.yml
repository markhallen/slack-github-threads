name: Auto-merge Dependabot PRs

on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions:
  contents: write
  pull-requests: write
  checks: read

jobs:
  auto-merge:
    runs-on: ubuntu-latest
    if: github.actor == 'dependabot[bot]'

    steps:
      - name: Check if PR is patch update
        id: check-patch
        uses: actions/github-script@v7
        with:
          script: |
            const title = context.payload.pull_request.title;
            const isPatch = title.includes('patch') ||
                           title.match(/bump .+ from \d+\.\d+\.\d+ to \d+\.\d+\.\d+$/);
            const isSecurityUpdate = title.includes('security') ||
                                   context.payload.pull_request.labels.some(label =>
                                     label.name === 'security' || label.name === 'vulnerability'
                                   );

            console.log(`PR Title: ${title}`);
            console.log(`Is patch update: ${isPatch}`);
            console.log(`Is security update: ${isSecurityUpdate}`);

            return {
              should_auto_merge: isPatch || isSecurityUpdate,
              is_patch: isPatch,
              is_security: isSecurityUpdate
            };

      - name: Wait for CI to complete
        if: fromJSON(steps.check-patch.outputs.result).should_auto_merge
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const pr_number = context.payload.pull_request.number;

            // Wait for all checks to complete
            let allChecksPassed = false;
            let attempts = 0;
            const maxAttempts = 30; // Wait up to 15 minutes (30 * 30s)

            while (!allChecksPassed && attempts < maxAttempts) {
              attempts++;

              const { data: checks } = await github.rest.checks.listForRef({
                owner,
                repo,
                ref: context.payload.pull_request.head.sha,
              });

              const { data: statuses } = await github.rest.repos.listCommitStatusesForRef({
                owner,
                repo,
                ref: context.payload.pull_request.head.sha,
              });

              const allChecks = [...checks.check_runs, ...statuses];
              
              // Filter out this workflow to avoid waiting for itself
              const relevantChecks = allChecks.filter(check => {
                const checkName = check.name || check.context || '';
                // Exclude auto-merge workflows
                if (checkName.includes('auto-merge') || checkName.includes('Auto-merge')) {
                  return false;
                }
                // Only wait for actual CI/test checks
                return checkName.includes('CI') || 
                       checkName.includes('test') || 
                       checkName.includes('build') ||
                       checkName.includes('lint') ||
                       checkName.includes('RuboCop') ||
                       checkName === 'ci'; // Our specific CI workflow
              });
              
              console.log(`Total checks found: ${allChecks.length}`);
              console.log(`Relevant checks after filtering: ${relevantChecks.length}`);
              if (relevantChecks.length > 0) {
                console.log('Relevant checks:', relevantChecks.map(c => c.name || c.context).join(', '));
              }
              
              const pendingChecks = relevantChecks.filter(check =>
                check.status === 'queued' ||
                check.status === 'in_progress' ||
                check.state === 'pending'
              );

              const failedChecks = relevantChecks.filter(check =>
                check.conclusion === 'failure' ||
                check.conclusion === 'cancelled' ||
                check.state === 'failure' ||
                check.state === 'error'
              );

              if (failedChecks.length > 0) {
                console.log('Some checks failed, will not auto-merge');
                console.log('Failed checks:', failedChecks.map(c => c.name || c.context).join(', '));
                return;
              }

              if (relevantChecks.length === 0) {
                console.log('No relevant CI checks found, proceeding with merge');
                allChecksPassed = true;
              } else if (pendingChecks.length === 0) {
                allChecksPassed = true;
                console.log('All relevant checks passed!');
              } else {
                console.log(`Waiting for ${pendingChecks.length} checks to complete...`);
                console.log('Pending checks:', pendingChecks.map(c => c.name || c.context).join(', '));
                await new Promise(resolve => setTimeout(resolve, 30000)); // Wait 30 seconds
              }
            }

            if (!allChecksPassed) {
              console.log('Timeout waiting for checks to complete');
              return;
            }

            // Enable auto-merge
            await github.rest.pulls.merge({
              owner,
              repo,
              pull_number: pr_number,
              merge_method: 'squash',
              commit_title: `${context.payload.pull_request.title} (#${pr_number})`,
              commit_message: 'Auto-merged by Dependabot workflow'
            });

            console.log('PR auto-merged successfully!');

      - name: Add comment on successful merge
        if: fromJSON(steps.check-patch.outputs.result).should_auto_merge
        uses: actions/github-script@v7
        with:
          script: |
            const result = ${{ steps.check-patch.outputs.result }};
            const updateType = result.is_security ? 'security update' : 'patch update';

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              body: `ðŸ¤– Auto-merged this ${updateType} after all checks passed successfully!`
            });
